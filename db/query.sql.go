// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllTestcases = `-- name: GetAllTestcases :many
SELECT 
    q.id AS question_id, 
    q.body AS question_body, 
    q.driver_code, 
    q.email AS author_email, 
    t.id AS testcase_id, 
    t.input AS testcase_input, 
    t.output AS testcase_output, 
    t.order AS testcase_order
FROM "Question" q
LEFT JOIN "Testcases" t ON q.id = t.qid
WHERE q.id = $1
ORDER BY t.order ASC
`

type GetAllTestcasesRow struct {
	QuestionID     int32
	QuestionBody   string
	DriverCode     pgtype.Text
	AuthorEmail    string
	TestcaseID     pgtype.Int4
	TestcaseInput  pgtype.Text
	TestcaseOutput pgtype.Text
	TestcaseOrder  pgtype.Int4
}

func (q *Queries) GetAllTestcases(ctx context.Context, id int32) ([]GetAllTestcasesRow, error) {
	rows, err := q.db.Query(ctx, getAllTestcases, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTestcasesRow
	for rows.Next() {
		var i GetAllTestcasesRow
		if err := rows.Scan(
			&i.QuestionID,
			&i.QuestionBody,
			&i.DriverCode,
			&i.AuthorEmail,
			&i.TestcaseID,
			&i.TestcaseInput,
			&i.TestcaseOutput,
			&i.TestcaseOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionFromId = `-- name: GetQuestionFromId :one
SELECT id, body, driver_code, email FROM "Question"
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetQuestionFromId(ctx context.Context, id int32) (Question, error) {
	row := q.db.QueryRow(ctx, getQuestionFromId, id)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.DriverCode,
		&i.Email,
	)
	return i, err
}

const getUserFromEmail = `-- name: GetUserFromEmail :one
SELECT id, username, password, name, email, picture, auth_type FROM "User"
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserFromEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserFromEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Name,
		&i.Email,
		&i.Picture,
		&i.AuthType,
	)
	return i, err
}

const getUserFromUsername = `-- name: GetUserFromUsername :one
SELECT id, username, password, name, email, picture, auth_type FROM "User"
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserFromUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserFromUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Name,
		&i.Email,
		&i.Picture,
		&i.AuthType,
	)
	return i, err
}

const insertSubmission = `-- name: InsertSubmission :one
INSERT INTO "Submission" (
    "code",
    "message",
    "correct",
    "question_id",
    "language",
    "duration",
    "email"
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, code, question_id, message, correct, language, duration, email
`

type InsertSubmissionParams struct {
	Code       string
	Message    string
	Correct    bool
	QuestionID int32
	Language   string
	Duration   int64
	Email      string
}

func (q *Queries) InsertSubmission(ctx context.Context, arg InsertSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, insertSubmission,
		arg.Code,
		arg.Message,
		arg.Correct,
		arg.QuestionID,
		arg.Language,
		arg.Duration,
		arg.Email,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.QuestionID,
		&i.Message,
		&i.Correct,
		&i.Language,
		&i.Duration,
		&i.Email,
	)
	return i, err
}
